"""
Tool Executor - Generic tool call handling with MCP routing

This module handles tool call execution from AI assistants, routing calls
to appropriate backends (Google MCP client or traditional tool manager).

Extracted from chat_tool_handler.py (Phase 3 - January 2025)
"""

from __future__ import annotations

import json
import logging
from typing import List, Dict, Any

logger = logging.getLogger(__name__)


async def handle_tool_calls(user_id: str, tool_calls: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Handle tool calls from the AI assistant with MCP integration.

    Processes a list of tool calls generated by the AI assistant, routing each
    call to the appropriate execution backend:
    - Google MCP client for Google services (Gmail, Drive, Calendar)
    - Traditional tool manager for other tools

    Ensures the MCP client is connected before executing Google tools and
    handles errors gracefully by returning error results instead of raising
    exceptions.

    Args:
        user_id (str): Unique identifier for the user making the request. Used
            for authentication and authorization with tool backends.
        tool_calls (List[Dict[str, Any]]): List of tool call dictionaries from
            the AI assistant. Each should contain:
            - id: Unique identifier for the tool call
            - function: Dict with 'name' and 'arguments' (string or dict)

    Returns:
        List[Dict[str, Any]]: List of tool execution results. Each result contains:
            - tool_call_id (str): The ID of the tool call
            - tool_name (str): Name of the executed tool
            - result (Dict[str, Any]): Execution result with 'success' and either
              'response' or 'error' fields

    Raises:
        Does not raise exceptions. All errors are caught and returned as error
        results in the output list.

    Example:
        >>> tool_calls = [{
        ...     'id': 'call_123',
        ...     'function': {
        ...         'name': 'gmail_recent',
        ...         'arguments': '{"max_results": 5}'
        ...     }
        ... }]
        >>> results = await handle_tool_calls('user123', tool_calls)
        >>> results[0]['result']['success']
        True
    """
    tool_results = []

    # Import here to avoid circular dependency
    from .mcp_client import google_mcp_client
    from .tool_manager import tool_manager

    for tool_call in tool_calls:
        try:
            tool_name = tool_call.get("function", {}).get("name")
            tool_args = tool_call.get("function", {}).get("arguments", "{}")

            # Parse arguments
            if isinstance(tool_args, str):
                tool_args = json.loads(tool_args)

            # Check if this is a Google MCP tool
            google_tools = [
                "gmail_search", "gmail_get_message", "gmail_recent", "gmail_important",
                "drive_list_files", "drive_create_folder", "drive_list_folder_files", "drive_shared_drives", "drive_search", "drive_search_folders",
                "calendar_list_events", "calendar_upcoming_events"
            ]

            if tool_name in google_tools:
                # Use MCP client for Google services
                logger.debug(f"üîß Using MCP client for tool: {tool_name}")
                logger.debug(f"üîß Tool arguments: {tool_args}")
                logger.debug(f"üîß User ID: {user_id}")
                try:
                    # Ensure MCP client is connected
                    await google_mcp_client.connect()

                    # Add user_id to arguments for MCP
                    tool_args["user_id"] = user_id
                    logger.debug(f"üîß Final tool arguments: {tool_args}")

                    # Execute via MCP
                    result = await google_mcp_client.call_tool(tool_name, tool_args)

                    logger.debug(f"üîß MCP result for {tool_name}: {result}")

                    # Special debug logging for folder search
                    if tool_name == "drive_search_folders" and result.get("success"):
                        logger.debug(f"üîç FOLDER SEARCH RESULT: {result.get('response', 'No response')[:500]}")
                        if len(result.get('response', '')) > 500:
                            logger.debug(f"üîç FOLDER SEARCH (continued): {result.get('response', '')[500:]}")

                except Exception as e:
                    logger.error(f"‚ùå MCP tool execution failed for {tool_name}: {e}")
                    import traceback
                    traceback.print_exc()
                    result = {
                        "success": False,
                        "error": f"MCP tool execution failed: {str(e)}"
                    }

            else:
                # Use traditional tool manager for non-Google tools
                logger.debug(f"üîß Using traditional tool manager for: {tool_name}")
                result = await tool_manager.execute_tool(tool_name, user_id, **tool_args)

            tool_results.append({
                "tool_call_id": tool_call.get("id"),
                "tool_name": tool_name,
                "result": result
            })

        except Exception as e:
            logger.error(f"‚ùå Tool execution failed for {tool_name}: {e}")
            tool_results.append({
                "tool_call_id": tool_call.get("id"),
                "tool_name": tool_call.get("function", {}).get("name", "unknown"),
                "result": {
                    "success": False,
                    "error": f"Tool execution failed: {str(e)}"
                }
            })

    return tool_results
